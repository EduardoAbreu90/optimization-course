# Função 105 - Rosembrock  
import numpy as np
import matplotlib.pyplot as plt
from tabulate import tabulate

def rosenbrock(x, D):
    """Calcula o valor da função Rosenbrock para D dimensões"""
    return sum(100*(x[i+1] - x[i]**2)**2 + (x[i] - 1)**2 for i in range(D-1))

def rosenbrock_gradient(x, D):
    """Calcula o gradiente da função Rosenbrock"""
    grad = np.zeros(D)
    for i in range(D-1):
        grad[i] += -400 * x[i] * (x[i+1] - x[i]**2) + 2 * (x[i] - 1)
        grad[i+1] += 200 * (x[i+1] - x[i]**2)
    return grad

# Configurações diferentes do exemplo anterior
dimensoes = [3, 7, 15, 25, 50]  # Valores diferentes de D
num_pontos = 4                    # Número de pontos por dimensão
np.random.seed(123)               # Semente diferente para variedade

# Gerar dados
dados = []
for D in dimensoes:
    pontos = [np.random.uniform(-1.5, 1.5, D) for _ in range(num_pontos)]
    valores = [rosenbrock(p, D) for p in pontos]
    normas_grad = [np.linalg.norm(rosenbrock_gradient(p, D)) for p in pontos]
    
    dados.append({
        'Dimensão': D,
        'Pontos': pontos,
        'Valores': valores,
        'Norma Grad': normas_grad
    })

# Exibir tabela comparativa
tabela = []
for item in dados:
    for i in range(num_pontos):
        tabela.append([
            item['Dimensão'] if i == 0 else "",
            f"Ponto {i+1}",
            f"{item['Valores'][i]:.2e}",
            f"{item['Norma Grad'][i]:.2e}"
        ])

print(tabulate(tabela, 
               headers=["D", "Ponto", "f(x)", "‖∇f(x)‖"], 
               tablefmt="grid",
               floatfmt=".2e"))

# Visualização para D=3 (cortes 2D)
if 3 in dimensoes:
    D = 3
    idx = dimensoes.index(3)
    
    # Preparar dados para visualização
    x = np.linspace(-1.5, 1.5, 100)
    y = np.linspace(-1.5, 1.5, 100)
    X, Y = np.meshgrid(x, y)
    
    # Cortes mantendo a terceira dimensão fixa
    Z1 = np.zeros_like(X)  # x3 = 0
    Z2 = np.zeros_like(X)  # x3 = 1
    
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            Z1[i,j] = rosenbrock(np.array([X[i,j], Y[i,j], 0]), D)
            Z2[i,j] = rosenbrock(np.array([X[i,j], Y[i,j], 1]), D)
    
    # Plotar
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # Corte com x3 = 0
    cont1 = ax1.contourf(X, Y, np.log(Z1+1), levels=20, cmap='viridis')
    ax1.set_title('Corte da Rosenbrock 3D (x3 = 0) - Escala log')
    ax1.set_xlabel('x1')
    ax1.set_ylabel('x2')
    fig.colorbar(cont1, ax=ax1)
    
    # Corte com x3 = 1
    cont2 = ax2.contourf(X, Y, np.log(Z2+1), levels=20, cmap='plasma')
    ax2.set_title('Corte da Rosenbrock 3D (x3 = 1) - Escala log')
    ax2.set_xlabel('x1')
    ax2.set_ylabel('x2')
    fig.colorbar(cont2, ax=ax2)
    
    plt.tight_layout()
    plt.show()

# Análise de convergência para diferentes D
print("\nAnálise de Médias:")
analise = []
for item in dados:
    analise.append([
        item['Dimensão'],
        f"{np.mean(item['Valores']):.2e} ± {np.std(item['Valores']):.2e}",
        f"{np.mean(item['Norma Grad']):.2e}",
        f"{min(item['Valores']):.2e}"
    ])

print(tabulate(analise, 
               headers=["D", "Média f(x) ± DP", "Média ‖∇f(x)‖", "Mínimo f(x)"], 
               tablefmt="grid",
               floatfmt=".2e"))

# Função 114 - Scahffer 3
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D

def scalifier3(x1, x2):
    """Calcula o valor da função Scalifier 3"""
    termo_sin = np.sin(np.cos(np.abs(x1**2 - x2**2)))**2
    denominador = 1 + 0.001*(x1**2 + x2**2)**2
    return 0.5 + (termo_sin - 0.5) / denominador

# Definindo novos conjuntos de pontos iniciais
conjuntos_pontos = {
    "Próximos ao mínimo": [
        [0.0, 1.2],
        [0.1, 1.253115],
        [-0.05, 1.1],
        [0.0, 1.5]
    ],
    "Pontos distantes": [
        [75.0, -80.0],
        [-90.0, 95.0],
        [100.0, -100.0],
        [-100.0, 0.0]
    ],
    "Pontos especiais": [
        [1.253115, 1.253115],
        [-1.253115, 0.0],
        [2.0, 2.0],
        [-3.0, 3.0]
    ],
    "Pontos médios": [
        [10.0, 10.0],
        [-15.0, 20.0],
        [25.0, -30.0],
        [-40.0, 40.0]
    ]
}

# Calculando os valores para cada conjunto
resultados = {}
for nome, pontos in conjuntos_pontos.items():
    resultados[nome] = [(x1, x2, scalifier3(x1, x2)) for x1, x2 in pontos]

# Exibindo os resultados em formato tabular
print("{:<20} {:<15} {:<15} {:<15}".format("Conjunto", "x1", "x2", "f(x1,x2)"))
print("="*65)
for nome, valores in resultados.items():
    print(f"→ {nome}:")
    for x1, x2, val in valores:
        print("{:<20} {:<15.6f} {:<15.6f} {:<15.6f}".format("", x1, x2, val))
    print("-"*65)

# Visualização 3D com destaque para regiões diferentes
fig = plt.figure(figsize=(18, 12))

# 1. Superfície 3D completa
ax1 = fig.add_subplot(231, projection='3d')
x = np.linspace(-100, 100, 200)
y = np.linspace(-100, 100, 200)
X, Y = np.meshgrid(x, y)
Z = scalifier3(X, Y)
surf = ax1.plot_surface(X, Y, Z, cmap=cm.coolwarm, alpha=0.6)
ax1.set_title('Visão Global (-100 a 100)')
ax1.set_zlim(0, 1)

# 2. Zoom na região próxima ao mínimo
ax2 = fig.add_subplot(232, projection='3d')
x_zoom = np.linspace(-2, 2, 100)
y_zoom = np.linspace(0, 2.5, 100)
Xz, Yz = np.meshgrid(x_zoom, y_zoom)
Zz = scalifier3(Xz, Yz)
surf_z = ax2.plot_surface(Xz, Yz, Zz, cmap=cm.viridis)
ax2.set_title('Zoom no Mínimo (x1:[-2,2], x2:[0,2.5])')
ax2.set_zlim(0, 1)

# 3. Mapa de contorno
ax3 = fig.add_subplot(233)
contour = ax3.contourf(Xz, Yz, Zz, levels=50, cmap=cm.viridis)
plt.colorbar(contour, ax=ax3)
ax3.set_title('Mapa de Contorno na Região do Mínimo')
ax3.set_xlabel('x1')
ax3.set_ylabel('x2')

# Marcando pontos especiais no contorno
for nome, pontos in conjuntos_pontos.items():
    for x1, x2 in pontos:
        if abs(x1) <= 2 and 0 <= x2 <= 2.5:  # Só mostra pontos dentro da área do zoom
            ax3.plot(x1, x2, 'o', markersize=8, label=f'({x1:.2f},{x2:.2f})')

ax3.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

# 4. Gráfico de valores por conjunto
ax4 = fig.add_subplot(212)
for i, (nome, valores) in enumerate(resultados.items()):
    x = [f"Ponto {j+1}" for j in range(len(valores))]
    y = [val for _, _, val in valores]
    ax4.plot(x, y, 'o-', label=nome, markersize=8)

ax4.axhline(y=0.00156685, color='r', linestyle='--', label='Mínimo global')
ax4.set_title('Comparação de Valores entre Conjuntos')
ax4.set_ylabel('f(x1,x2)')
ax4.legend()
ax4.grid(True)

plt.tight_layout()
plt.show()

# Função 142 - Streched V Sine Wave Function
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def streched_v_sine_wave(x, D):
    """Calcula o valor da função Streched V Sine Wave para um vetor x de dimensão D."""
    total = 0.0
    for i in range(D - 1):
        sum_sq = x[i+1]**2 + x[i]**2
        term = (sum_sq)**0.25 * (np.sin(50 * (sum_sq)**0.1)**2 + 0.1)
        total += term
    return total

# --- Configurações ---
D_values = [2, 3, 4]  # Dimensões a serem testadas
num_samples = 3       # Número de amostras por D
fixed_range = (-5, 5) # Novo intervalo para x_i (diferente do original [-10, 10])

# --- Função para gerar amostras ---
def generate_samples(D, num_samples, x_range):
    return np.random.uniform(x_range[0], x_range[1], (num_samples, D))

# --- Avaliação para cada D ---
results = {}
for D in D_values:
    samples = generate_samples(D, num_samples, fixed_range)
    results[D] = []
    print(f"\n=== D = {D} (Intervalo x_i ∈ [{fixed_range[0]}, {fixed_range[1]}]) ===")
    for j, x in enumerate(samples):
        value = streched_v_sine_wave(x, D)
        results[D].append((x.round(2), value.round(4)))
        print(f"Amostra {j+1}: x = {x.round(2)} → f(x) = {value:.4f}")

# --- Gráficos para D = 2 e D = 3 ---
plt.figure(figsize=(15, 5))

# Gráfico 3D para D=2
if 2 in D_values:
    x1 = np.linspace(fixed_range[0], fixed_range[1], 100)
    x2 = np.linspace(fixed_range[0], fixed_range[1], 100)
    X1, X2 = np.meshgrid(x1, x2)
    Z = np.zeros_like(X1)
    for i in range(X1.shape[0]):
        for j in range(X1.shape[1]):
            Z[i, j] = streched_v_sine_wave(np.array([X1[i, j], X2[i, j]]), 2)
    
    ax1 = plt.subplot(131, projection='3d')
    ax1.plot_surface(X1, X2, Z, cmap='plasma', alpha=0.8)
    ax1.set_title(f'Superfície 3D (D=2)\nIntervalo: {fixed_range}')
    ax1.set_xlabel('x1')
    ax1.set_ylabel('x2')

# Gráfico de corte para D=3 (fixando x3=0)
if 3 in D_values:
    x1 = np.linspace(fixed_range[0], fixed_range[1], 100)
    x2 = np.linspace(fixed_range[0], fixed_range[1], 100)
    X1, X2 = np.meshgrid(x1, x2)
    Z = np.zeros_like(X1)
    for i in range(X1.shape[0]):
        for j in range(X1.shape[1]):
            Z[i, j] = streched_v_sine_wave(np.array([X1[i, j], X2[i, j], 0]), 3)
    
    ax2 = plt.subplot(132)
    contour = ax2.contourf(X1, X2, Z, levels=20, cmap='plasma')
    plt.colorbar(contour, ax=ax2)
    ax2.set_title(f'Corte 2D (D=3, x3=0)\nIntervalo: {fixed_range}')
    ax2.set_xlabel('x1')
    ax2.set_ylabel('x2')

# Gráfico de valores para D=4 (amostras aleatórias)
if 4 in D_values:
    samples_D4 = generate_samples(4, 100, fixed_range)
    values_D4 = [streched_v_sine_wave(x, 4) for x in samples_D4]
    
    ax3 = plt.subplot(133)
    ax3.hist(values_D4, bins=20, color='purple', edgecolor='black')
    ax3.set_title(f'Distribuição de f(x) para D=4\nIntervalo: {fixed_range}')
    ax3.set_xlabel('f(x)')
    ax3.set_ylabel('Frequência')

plt.tight_layout()
plt.show()

# Função 61 - Hansen
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D

# Nova versão da função de Hansen com coeficientes diferentes
def modified_hansen(x):
    x1, x2 = x
    term1 = sum((i + 2) * np.cos(i * x1 + i + 2) for i in range(1, 6))  # Alterado para 5 termos
    term2 = sum((j + 1.5) * np.cos((j + 1.5) * x2 + j + 2) for j in range(0, 5))  # Coeficientes não inteiros
    return term1 * term2

# Parâmetros para visualização
x = np.linspace(-12, 12, 150)  # Domínio ampliado
y = np.linspace(-12, 12, 150)
X, Y = np.meshgrid(x, y)
Z = np.zeros_like(X)

# Calculando os valores da função
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        Z[i,j] = modified_hansen([X[i,j], Y[i,j]])

# Encontrando mínimos globais numericamente
from scipy.optimize import basinhopping

# Função para encontrar múltiplos mínimos
def find_minima(n_tries=20):
    minima = []
    for _ in range(n_tries):
        x0 = np.random.uniform(-12, 12, 2)
        res = basinhopping(modified_hansen, x0, niter=50, T=1.0, stepsize=3.0)
        # Verifica se é um novo mínimo
        is_new = True
        for m in minima:
            if np.linalg.norm(res.x - m[0]) < 1.0:  # Tolerância de distância
                is_new = False
                break
        if is_new:
            minima.append((res.x, res.fun))
    return sorted(minima, key=lambda x: x[1])[:6]  # Retorna os 6 melhores mínimos

minima = find_minima()

# Configuração dos gráficos
plt.figure(figsize=(20, 7))

# Gráfico 1: Superfície 3D com nova paleta de cores
ax1 = plt.subplot(1, 3, 1, projection='3d')
surf = ax1.plot_surface(X, Y, Z, cmap=cm.viridis, alpha=0.7, antialiased=True)
ax1.set_title('Superfície da Função Modificada', pad=15)
ax1.set_xlabel('x1', labelpad=10)
ax1.set_ylabel('x2', labelpad=10)
ax1.set_zlabel('f(x1,x2)', labelpad=10)
ax1.view_init(elev=30, azim=45)
plt.colorbar(surf, ax=ax1, shrink=0.5, aspect=10, pad=0.1)

# Gráfico 2: Curvas de nível com mínimo global
ax2 = plt.subplot(1, 3, 2)
contour = ax2.contourf(X, Y, Z, levels=30, cmap=cm.plasma)
ax2.set_title('Mapa de Calor com Curvas de Nível', pad=15)
ax2.set_xlabel('x1', labelpad=10)
ax2.set_ylabel('x2', labelpad=10)

# Marcando todos os mínimos encontrados
for i, (coord, val) in enumerate(minima):
    color = 'gold' if i < 2 else 'silver'  # Destaca os dois primeiros
    ax2.scatter(coord[0], coord[1], color=color, s=80, edgecolor='black', linewidth=1)
    if i < 2:  # Anota apenas os dois principais
        ax2.annotate(f'Min {i+1}\n({coord[0]:.2f}, {coord[1]:.2f})\nf={val:.2f}',
                    (coord[0], coord[1]), xytext=(10, 15),
                    textcoords='offset points', ha='center',
                    bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", lw=1))

plt.colorbar(contour, ax=ax2, shrink=0.5, aspect=10, pad=0.1)

# Gráfico 3: Visualização em 3D dos mínimos
ax3 = plt.subplot(1, 3, 3, projection='3d')
ax3.plot_surface(X, Y, Z, cmap=cm.viridis, alpha=0.5)
ax3.set_title('Mínimos Globais em 3D', pad=15)
ax3.set_xlabel('x1', labelpad=10)
ax3.set_ylabel('x2', labelpad=10)
ax3.set_zlabel('f(x1,x2)', labelpad=10)

# Plotando os mínimos como esferas
for i, (coord, val) in enumerate(minima):
    color = 'gold' if i < 2 else 'silver'
    ax3.scatter([coord[0]], [coord[1]], [val], color=color, s=100, edgecolor='black', depthshade=False)
    if i < 2:
        ax3.text(coord[0], coord[1], val, f' Min {i+1}', color='black', zorder=10)

plt.tight_layout()
plt.show()

# Resultados numéricos detalhados
print("\nMínimos Globais Encontrados:")
print("{:<10} {:<15} {:<15} {:<15}".format("Mínimo", "x1", "x2", "f(x1,x2)"))
for i, (coord, val) in enumerate(minima):
    print(f"{i+1:<10} {coord[0]:<15.6f} {coord[1]:<15.6f} {val:<15.6f}")

# Comparação entre os dois principais mínimos
print("\nComparação entre os dois principais mínimos:")
diff_x = minima[1][0][0] - minima[0][0][0]
diff_y = minima[1][0][1] - minima[0][0][1]
print(f"Distância entre Mín 1 e Mín 2: {np.sqrt(diff_x**2 + diff_y**2):.4f} unidades")
print(f"Diferença nos valores: {abs(minima[1][1] - minima[0][1]):.6f}")
